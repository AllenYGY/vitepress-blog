import{_ as r,c as d,a5 as n,j as t,a as o,o as e}from"./chunks/framework.CHhwEXkI.js";const h=JSON.parse('{"title":"Regular-Expression","description":"","frontmatter":{"date":"2024-04-25T00:00:00.000Z","title":"Regular-Expression","status":"DONE","author":["AllenYGY"],"tags":["Regular-Expression","String","NOTE"],"created":"2024-04-25T15:16","updated":"2024-04-25T15:45","publish":true},"headers":[],"relativePath":"posts/Tools/Regex/Regular-Expression.md","filePath":"posts/Tools/Regex/Regular-Expression.md","lastUpdated":null}'),a={name:"posts/Tools/Regex/Regular-Expression.md"};function s(u,l,c,i,p,b){return e(),d("div",null,l[0]||(l[0]=[n('<h1 id="regular-expression" tabindex="-1">Regular-Expression <a class="header-anchor" href="#regular-expression" aria-label="Permalink to &quot;Regular-Expression&quot;">​</a></h1><h2 id="syntax" tabindex="-1">Syntax <a class="header-anchor" href="#syntax" aria-label="Permalink to &quot;Syntax&quot;">​</a></h2><p>正则表达式是一种用于匹配和操作文本的强大工具，它是由一系列字符和特殊字符组成的模式，用于描述要匹配的文本模式。</p><p>正则表达式可以在文本中查找、替换、提取和验证特定的模式。</p><div class="info custom-block github-alert"><p class="custom-block-title">- `+` 号代表前面的字符必须至少出现一次（1次或多次）</p><p></p><ul><li><code>runoo+b</code>，可以匹配 <strong>runoob、runooob、runoooooob</strong> 等</li></ul></div><div class="info custom-block github-alert"><p class="custom-block-title">- `*` 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）</p><p></p><ul><li><code>runoo*b</code>，可以匹配 <strong>runob、runoob、runoooooob</strong> 等</li></ul></div><div class="info custom-block github-alert"><p class="custom-block-title">- `?` 问号代表前面的字符最多只可以出现一次（0次或1次）</p><p></p><ul><li><code>colou?r</code> 可以匹配 <strong>color</strong> 或者 <strong>colour</strong></li></ul></div><p>构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。</p><p>正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为&quot;元字符&quot;）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p><h2 id="普通字符" tabindex="-1">普通字符 <a class="header-anchor" href="#普通字符" aria-label="Permalink to &quot;普通字符&quot;">​</a></h2><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p><div class="info custom-block github-alert"><p class="custom-block-title">- [ ] 匹配 [...] 中的所有字符</p><p></p><ul><li>[aeiou] 匹配字符串 &quot;google runoob taobao&quot; 中所有的 e o u a 字母。</li></ul></div><div class="info custom-block github-alert"><p class="custom-block-title">- [^ ] 匹配除了 [...] 中字符的所有字符</p><p></p><ul><li>[^aeiou] 匹配字符串 &quot;google runoob taobao&quot; 中除了 e o u a 字母的所有字符。</li></ul></div><div class="info custom-block github-alert"><p class="custom-block-title">- [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</p><p></p></div><div class="info custom-block github-alert"><p class="custom-block-title">- `.` 匹配除换行符（\\n、\\r）之外的任何单个字符，相等于 \\[^\\n\\r\\]。</p><p></p></div><div class="info custom-block github-alert"><p class="custom-block-title">- `\\w` 匹配字母、数字、下划线。等价于 [A-Za-z0-9_]</p><p></p></div><div class="info custom-block github-alert"><p class="custom-block-title">- `\\d` 匹配任意一个阿拉伯数字（0 到 9）。等价于 [0-9]</p><p></p></div><h2 id="非打印字符" tabindex="-1">非打印字符 <a class="header-anchor" href="#非打印字符" aria-label="Permalink to &quot;非打印字符&quot;">​</a></h2><table tabindex="0"><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\\cx</td><td>匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 &#39;c&#39; 字符。</td></tr><tr><td>\\f</td><td>匹配一个换页符。等价于 \\x0c 和 \\cL。</td></tr><tr><td>\\n</td><td>匹配一个换行符。等价于 \\x0a 和 \\cJ。</td></tr><tr><td>\\r</td><td>匹配一个回车符。等价于 \\x0d 和 \\cM。</td></tr><tr><td>\\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。</td></tr><tr><td>\\S</td><td>匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。</td></tr><tr><td>\\t</td><td>匹配一个制表符。等价于 \\x09 和 \\cI。</td></tr><tr><td>\\v</td><td>匹配一个垂直制表符。等价于 \\x0b 和 \\cK。</td></tr></tbody></table><h2 id="特殊字符" tabindex="-1">特殊字符 <a class="header-anchor" href="#特殊字符" aria-label="Permalink to &quot;特殊字符&quot;">​</a></h2><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的 <code>runoo*b</code> 中的 <code>*</code>，简单的说就是表示任何字符串的意思。如果要查找字符串中的 <code>*</code> 符号，则需要对 <code>*</code> 进行转义，即在其前加一个 \\，<code>runo\\*ob</code> 匹配字符串 <code>**runo*ob**</code>。</p><p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符&quot;转义&quot;，即，<strong>将反斜杠字符\\ 放在它们前面</strong>。下表列出了正则表达式中的特殊字符：</p><table tabindex="0"><thead><tr><th>特别字符</th><th>描述</th></tr></thead><tbody><tr><td>$</td><td>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 &#39;\\n&#39; 或 &#39;\\r&#39;。要匹配 $ 字符本身，请使用 $。</td></tr><tr><td>( )</td><td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td></tr><tr><td>.</td><td>匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。</td></tr><tr><td>[</td><td>标记一个中括号表达式的开始。要匹配 [，请使用 [。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td></tr><tr><td>\\</td><td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， &#39;n&#39; 匹配字符 &#39;n&#39;。&#39;\\n&#39; 匹配换行符。序列 &#39;\\&#39; 匹配 &quot;&quot;，而 &#39;(&#39; 则匹配 &quot;(&quot;。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。</td></tr><tr><td>{</td><td>标记限定符表达式的开始。要匹配 {，请使用 {。</td></tr><tr><td>|</td><td>指明两项之间的一个选择。要匹配 |，请使用 \\|。</td></tr></tbody></table><h2 id="限定符" tabindex="-1">限定符 <a class="header-anchor" href="#限定符" aria-label="Permalink to &quot;限定符&quot;">​</a></h2><p>限定符用来指定正则表达式的一个给定组件<em>必须要出现多少次才能满足匹配</em>。</p><p><code>有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。</code></p><p>正则表达式的限定符有：</p>',27),t("table",{tabindex:"0"},[t("thead",null,[t("tr",null,[t("th",null,"字符"),t("th",null,"描述")])]),t("tbody",null,[t("tr",null,[t("td",null,"*"),t("td",null,[o("匹配前面的子表达式零次或多次。例如，zo* 能匹配 "),t("strong",null,'"z"'),o(" 以及 "),t("strong",null,'"zoo"'),o("。* 等价于 {0,}。")])]),t("tr",null,[t("td",null,"+"),t("td",null,[o("匹配前面的子表达式一次或多次。例如，zo+ 能匹配 "),t("strong",null,'"zo"'),o(' 以及 "'),t("strong",null,'zoo"'),o("，但不能匹配 "),t("strong",null,'"z"'),o("。+ 等价于 {1,}。")])]),t("tr",null,[t("td",null,"?"),t("td",null,[o("匹配前面的子表达式零次或一次。例如，do(es)? 可以匹配 "),t("strong",null,'"do"'),o(" 、 "),t("strong",null,'"does"'),o("、 "),t("strong",null,'"doxy"'),o(" 中的 "),t("strong",null,'"do"'),o(" 和 "),t("strong",null,'"does"'),o("。? 等价于 {0,1}。")])]),t("tr",null,[t("td",{n:""}),t("td",null,[o("n 是一个非负整数。匹配确定的 "),t("strong",null,"n"),o(" 次。例如，o{2} 不能匹配 "),t("strong",null,'"Bob"'),o(" 中的 "),t("strong",null,"o"),o("，但是能匹配 "),t("strong",null,'"food"'),o(" 中的两个 "),t("strong",null,"o"),o("。")])]),t("tr",null,[t("td",{"n,":""}),t("td",null,[o("n 是一个非负整数。至少匹配n 次。例如，o{2,} 不能匹配 "),t("strong",null,'"Bob"'),o(" 中的 "),t("strong",null,"o"),o("，但能匹配 "),t("strong",null,'"foooood"'),o(" 中的所有 "),t("strong",null,"o"),o("。o{1,} 等价于 o+。o{0,} 则等价于 o*。")])]),t("tr",null,[t("td",{"n,m":""}),t("td",null,[o("m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 "),t("strong",null,'"fooooood"'),o(" 中的前三个 "),t("strong",null,"o"),o("。o{0,1} 等价于 o?。请注意在逗号和两个数之间不能有空格。")])])])],-1),t("p",null,[o("匹配问号上面一行 "),t("code",null,"^(.*)\\n\\?\\s*$")],-1),t("p",null,"解决CSDN外链问题",-1),t("ul",null,[t("li",null,[t("p",null,[t("code",null,"!\\[.*\\]\\((.*?)\\)")])]),t("li",null,[t("p",null,[t("code",null,"<img src=$1>")])])],-1)]))}const m=r(a,[["render",s]]);export{h as __pageData,m as default};

import{_ as i,c as t,a5 as a,o as s}from"./chunks/framework.CHhwEXkI.js";const u=JSON.parse('{"title":"SE-Design and Implementation","description":"","frontmatter":{"date":"2025-05-27T00:00:00.000Z","title":"SE-Design and Implementation","status":"DONE","author":["AllenYGY"],"tags":["NOTE","Software-Engineering"],"publish":true},"headers":[],"relativePath":"posts/Software Engineering/Lecture/SE-Design and Implementation.md","filePath":"posts/Software Engineering/Lecture/SE-Design and Implementation.md","lastUpdated":null}'),n={name:"posts/Software Engineering/Lecture/SE-Design and Implementation.md"};function l(o,e,r,d,c,h){return s(),t("div",null,e[0]||(e[0]=[a('<h1 id="se-design-and-implementation" tabindex="-1">SE-Design and Implementation <a class="header-anchor" href="#se-design-and-implementation" aria-label="Permalink to &quot;SE-Design and Implementation&quot;">​</a></h1><h2 id="design" tabindex="-1">Design <a class="header-anchor" href="#design" aria-label="Permalink to &quot;Design&quot;">​</a></h2><h3 id="what-is-architectural-design" tabindex="-1">What is architectural design? <a class="header-anchor" href="#what-is-architectural-design" aria-label="Permalink to &quot;What is architectural design?&quot;">​</a></h3><p>A software architectural design is <em>an abstract decomposition</em> of a system into <em>large-grain components</em>, each of which may be a substantial system in its own right.</p><ul><li>Identify subsystems</li><li>Establish relationships between the subsystems</li></ul><h3 id="why-is-architecture-design-important" tabindex="-1">Why is architecture design important? <a class="header-anchor" href="#why-is-architecture-design-important" aria-label="Permalink to &quot;Why is architecture design important?&quot;">​</a></h3><p>A good software architecture can help</p><ul><li>Communication <ul><li>Developers in different phases can understand</li></ul></li><li>System analysis <ul><li>Complexity analysis</li></ul></li><li>Large scale reuse <ul><li>The reuse of subsystems</li></ul></li></ul><h3 id="how-can-we-assess-an-architecture" tabindex="-1">How can we assess an architecture? <a class="header-anchor" href="#how-can-we-assess-an-architecture" aria-label="Permalink to &quot;How can we assess an architecture?&quot;">​</a></h3><ul><li>Abstraction</li><li>Pattern</li><li>Modularity</li><li>Information hiding</li><li>Independence</li><li>Refinement</li><li>Refactoring</li></ul><h3 id="what-are-the-design-principles" tabindex="-1">What are the design principles <a class="header-anchor" href="#what-are-the-design-principles" aria-label="Permalink to &quot;What are the design principles&quot;">​</a></h3><ul><li><strong>Abstraction</strong>: Focusing on the essential aspects of an entity while ignoring accidental properties. This can be procedural or data abstraction.</li><li><strong>Pattern</strong>: Describing a design structure that solves a particular design problem within a specific context. Patterns should be sufficiently abstract to be reused in different settings. Architectural patterns, design patterns, and coding patterns exist.</li><li><strong>Modularity</strong>: The attribute of software that makes a program intellectually manageable, often employing a divide and conquer strategy to handle complexity.</li><li><strong>Information hiding</strong>: Design decisions within a module are invisible from outside the module. This helps reduce the impact of changes, facilitates component reuse, and simplifies interfaces.</li><li><strong>Independence</strong>: Assessed through Coupling and Cohesion. <ul><li><strong>Coupling</strong>: Measures the dependencies between two subsystems. Lower coupling is better. Communicating via parameter passing is generally the best, while communicating via global data is worst.</li><li><strong>Cohesion</strong>: The measure of the functional relatedness within a module or subsystem. Higher cohesion is better. Decomposition should aim for high cohesion and low coupling.</li></ul></li><li><strong>Refinement</strong>: A process of elaboration, which is the opposite of abstraction, moving from abstract concepts to more specific details.</li><li><strong>Refactoring</strong>: A method that reorganizes the architecture to improve the design.</li></ul><h3 id="what-design-models-have-we-learnt" tabindex="-1">What design models have we learnt <a class="header-anchor" href="#what-design-models-have-we-learnt" aria-label="Permalink to &quot;What design models have we learnt&quot;">​</a></h3><ul><li>Repository model <ul><li>Repository is shared by the subsystems <img src="https://cdn.jsdelivr.net/gh/AllenYGY/ImageSpace@main/uPic/A8Jw6E.png" alt="A8Jw6E"></li><li>Advantages: No direct transmission between two subsystems</li><li>Disadvantages: <ul><li>The information handling is centralized</li><li>The changes in repository may affect many subsystems</li><li>The repository manager is responsible</li><li>Subsystem cannot have their own policies</li></ul></li></ul></li><li>Client-Server model <ul><li>The services offered by servers can be used by clients through network <img src="https://cdn.jsdelivr.net/gh/AllenYGY/ImageSpace@main/uPic/wE63po.png" alt="wE63po"></li></ul></li><li>Layered model <ul><li>The upper layers use the lower layers through defined standard interface <img src="https://cdn.jsdelivr.net/gh/AllenYGY/ImageSpace@main/uPic/T4mmML.png" alt="T4mmML"></li></ul></li><li>MVC model (Model-View-Controller) often used in combination with others like the Layered model <img src="https://cdn.jsdelivr.net/gh/AllenYGY/ImageSpace@main/uPic/PgIjLF.png" alt="PgIjLF"> <img src="https://cdn.jsdelivr.net/gh/AllenYGY/ImageSpace@main/uPic/pp9FBp.png" alt="pp9FBp"><ul><li>Model subsystems: maintain the real world objects</li><li>View subsystems: display the data in model subsystems to users</li><li>Controller subsystems: manage the sequence of interactions with the users</li><li>Model does not depend on any view or controller</li><li>Changes in the models are detected and displayed by view subsystems subsystems</li></ul></li></ul><h3 id="object-oriented-software-development" tabindex="-1">Object-Oriented Software Development <a class="header-anchor" href="#object-oriented-software-development" aria-label="Permalink to &quot;Object-Oriented Software Development&quot;">​</a></h3><ul><li>Develop the software which is a collection of objects that incorporate both data structure and behavior</li><li>OO software development <ul><li>Object-Oriented Analysis (<em>Requirements specification</em>)</li><li>Object-Oriented Design (<em>Architectural Design</em>)</li><li>Object Design (<em>Detailed Design</em>)</li><li>Object-Oriented Programming (<em>Implementation</em>)</li></ul></li><li>Essence <ul><li>Identify and organize the application domain objects</li><li>Do NOT consider the representation in programming languages</li></ul></li></ul><h3 id="what-is-detailed-design" tabindex="-1">What is detailed design? <a class="header-anchor" href="#what-is-detailed-design" aria-label="Permalink to &quot;What is detailed design?&quot;">​</a></h3><ul><li>Detailed design: <ul><li>refine the classes from the perspective of programming,</li><li>prepare for implementation,</li><li>Give detailed information for implementation</li></ul></li></ul><h3 id="what-do-we-do-in-detailed-design" tabindex="-1">What do we do in detailed design? <a class="header-anchor" href="#what-do-we-do-in-detailed-design" aria-label="Permalink to &quot;What do we do in detailed design?&quot;">​</a></h3><ul><li>Refine the classes from the perspective of programming.</li><li>Prepare for implementation.</li><li>Give detailed information for implementation.</li><li>Perform Interface design for classes. <ul><li>Identify missing attributes and operations.</li><li>Specify the signature of attributes (e.g., range, built-in types).</li><li>Specify the signature of operations (return type, name, parameters, their types).</li><li>Specify the visibility of attributes and operations (private, protected, public).</li><li>Specify pre- and post-conditions for methods if necessary.</li><li>The goal is to make the class interface more detailed.</li></ul></li><li>Perform restructuring of the design. <ul><li>This means adjusting the design towards implementation.</li><li>In Object-Oriented design, this can involve changing n-ary associations to binary, increasing inheritance, collapsing classes into attributes, or using qualifiers.</li><li>In Structured Design, this involves restructuring the structured call tree based on considerations like Coupling, Cohesion, and Database process.</li></ul></li></ul><h3 id="why-do-we-need-detailed-design" tabindex="-1">Why do we need detailed design? <a class="header-anchor" href="#why-do-we-need-detailed-design" aria-label="Permalink to &quot;Why do we need detailed design?&quot;">​</a></h3><ul><li>To refine the classes from the perspective of programming.</li><li>To prepare for implementation.</li><li>To give detailed information for implementation.</li><li>To make the class interface more detailed through interface design.</li><li>To restructure the design towards implementation.</li></ul><h3 id="object-oriented-design-an-example" tabindex="-1">Object-Oriented Design-An Example <a class="header-anchor" href="#object-oriented-design-an-example" aria-label="Permalink to &quot;Object-Oriented Design-An Example&quot;">​</a></h3><ul><li><ol><li>Group objects into subsystems that can be implemented by individuals</li></ol><ul><li>Assign objects identified in one use case into the same subsystem</li><li>Create a dedicated <em>专用</em> subsystem for objects used for moving data among subsystems</li><li>Minimize the number of associations crossing subsystem boundaries</li><li>All objects in the same subsystem should be functionally related.</li></ul></li><li><ol start="2"><li>Design an architecture for each subsystem</li></ol><ul><li>Use layered model + MVC model</li></ul></li><li><ol start="3"><li>Identify the persistent data</li></ol><ul><li>Each persistent class should be saved in a table</li><li>Each association should be saved too.</li></ul></li><li><ol start="4"><li>Refine Architecture</li></ol><ul><li>Allocate the tables to storage in different subsystem. One table cannot appear in multiple subsystems.</li></ul></li><li><p>We can group the objects into subsystems so that they can be developed by individuals.</p></li><li><p>A system decomposition can be revised by merging, splitting, and add systems.</p></li><li><p>For every subsystem, we can give the further architecture for it.</p></li><li><p>The design fundamentals must be followed in the architecture design.</p></li></ul>',24)]))}const g=i(n,[["render",l]]);export{u as __pageData,g as default};

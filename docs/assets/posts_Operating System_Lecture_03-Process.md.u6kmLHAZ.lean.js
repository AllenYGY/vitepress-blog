import{_ as n,c as t,a5 as l,j as e,a as s,o as a}from"./chunks/framework.CHhwEXkI.js";const w=JSON.parse('{"title":"03-Process","description":"","frontmatter":{"date":"2024-03-15T00:00:00.000Z","title":"03-Process","status":"DONE","tags":["OS","NOTE","Lec3"],"archived":true,"author":["AllenYGY"],"created":"2024-03-20T17:14","updated":"2024-03-22T00:00:00.000Z","publish":true},"headers":[],"relativePath":"posts/Operating System/Lecture/03-Process.md","filePath":"posts/Operating System/Lecture/03-Process.md","lastUpdated":null}'),o={name:"posts/Operating System/Lecture/03-Process.md"},r={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},c={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.054ex"},xmlns:"http://www.w3.org/2000/svg",width:"2.262ex",height:"1.242ex",role:"img",focusable:"false",viewBox:"0 -525 1000 549","aria-hidden":"true"},p={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},h={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.054ex"},xmlns:"http://www.w3.org/2000/svg",width:"2.262ex",height:"1.242ex",role:"img",focusable:"false",viewBox:"0 -525 1000 549","aria-hidden":"true"},d={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},u={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.054ex"},xmlns:"http://www.w3.org/2000/svg",width:"2.262ex",height:"1.242ex",role:"img",focusable:"false",viewBox:"0 -525 1000 549","aria-hidden":"true"},m={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},k={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.054ex"},xmlns:"http://www.w3.org/2000/svg",width:"2.262ex",height:"1.242ex",role:"img",focusable:"false",viewBox:"0 -525 1000 549","aria-hidden":"true"};function g(b,i,y,f,E,v){return a(),t("div",null,[i[16]||(i[16]=l('<h1 id="process" tabindex="-1">Process <a class="header-anchor" href="#process" aria-label="Permalink to &quot;Process&quot;">​</a></h1><h2 id="process-concept" tabindex="-1">Process Concept <a class="header-anchor" href="#process-concept" aria-label="Permalink to &quot;Process Concept&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">+ Process</p><p></p><ul><li>a program in execution in memory</li><li>execution must progress in sequential fashion</li></ul></div><p>There can be several process for one program <img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/OS/Process/process-1.png" alt="process"></p><h3 id="elf-object-file-format" tabindex="-1">ELF Object File Format <a class="header-anchor" href="#elf-object-file-format" aria-label="Permalink to &quot;ELF Object File Format&quot;">​</a></h3><p>ELF<code>Executable and Linkable Format</code><img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/OS/Process/ELF-1.png" alt="ELF"><img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/OS/Process/ELF-Format.png" alt="ELF-Format.png "></p><div class="note custom-block github-alert"><p class="custom-block-title">+ A process includes multiple parts</p><p></p><ul><li>the program code (also called text section)</li><li>stack containing temporary data <ul><li>E.g., function parameters, return addresses, local variables</li></ul></li><li>data section containing global variables and static variables</li><li>heap containing memory dynamically allocated during run time</li><li>program counter, processor registers (include all current )</li></ul></div><h2 id="process-state" tabindex="-1">Process State <a class="header-anchor" href="#process-state" aria-label="Permalink to &quot;Process State&quot;">​</a></h2><ul><li>New: The process is being created <code>创建状态</code></li><li>Running: Instructions are being executed by CPU <code>运行状态</code></li><li>Waiting: The process is waiting for some event to occur <code>阻塞状态</code></li><li>Ready: The process is waiting to be assigned to a processor <code>就绪状态</code></li><li>Terminated: The process has finished execution <code>终止状态</code></li></ul><h3 id="transform-between-process-state" tabindex="-1">Transform between process State <a class="header-anchor" href="#transform-between-process-state" aria-label="Permalink to &quot;Transform between process State&quot;">​</a></h3><p><img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/OS/ProcessState.png" alt="ProcessState"></p>',11)),e("ul",null,[e("li",null,[i[2]||(i[2]=s("Ready ")),e("mjx-container",r,[(a(),t("svg",c,i[0]||(i[0]=[e("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[e("g",{"data-mml-node":"math"},[e("g",{"data-mml-node":"mo"},[e("path",{"data-c":"21D2",d:"M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z",style:{"stroke-width":"3"}})])])],-1)]))),i[1]||(i[1]=e("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("mo",{stretchy:"false"},"⇒")])],-1))]),i[3]||(i[3]=s(" Running"))]),e("li",null,[i[6]||(i[6]=s("Running ")),e("mjx-container",p,[(a(),t("svg",h,i[4]||(i[4]=[e("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[e("g",{"data-mml-node":"math"},[e("g",{"data-mml-node":"mo"},[e("path",{"data-c":"21D2",d:"M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z",style:{"stroke-width":"3"}})])])],-1)]))),i[5]||(i[5]=e("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("mo",{stretchy:"false"},"⇒")])],-1))]),i[7]||(i[7]=s(" Ready"))]),e("li",null,[i[10]||(i[10]=s("Running ")),e("mjx-container",d,[(a(),t("svg",u,i[8]||(i[8]=[e("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[e("g",{"data-mml-node":"math"},[e("g",{"data-mml-node":"mo"},[e("path",{"data-c":"21D2",d:"M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z",style:{"stroke-width":"3"}})])])],-1)]))),i[9]||(i[9]=e("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("mo",{stretchy:"false"},"⇒")])],-1))]),i[11]||(i[11]=s(" Waiting"))]),e("li",null,[i[14]||(i[14]=s("Waiting ")),e("mjx-container",m,[(a(),t("svg",k,i[12]||(i[12]=[e("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[e("g",{"data-mml-node":"math"},[e("g",{"data-mml-node":"mo"},[e("path",{"data-c":"21D2",d:"M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z",style:{"stroke-width":"3"}})])])],-1)]))),i[13]||(i[13]=e("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("mo",{stretchy:"false"},"⇒")])],-1))]),i[15]||(i[15]=s(" Ready"))])]),i[17]||(i[17]=l(`<h2 id="process-control-block-pcb" tabindex="-1">Process Control Block <em>PCB</em> <a class="header-anchor" href="#process-control-block-pcb" aria-label="Permalink to &quot;Process Control Block *PCB*&quot;">​</a></h2><div class="tip custom-block github-alert"><p class="custom-block-title">+ PCB</p><p></p><ol><li>PCB: Information associated with each process, can be stored in a struct type <code>also called task control block</code></li><li>A PCB is a kernel data structure <code>PCB 是内核的数据结构</code></li><li>Each process has a corresponding unique PCB in the kernel <code>PCB 是进程的唯一标志</code></li></ol></div><div class="info custom-block github-alert"><p class="custom-block-title">+ PCB Include</p><p></p><ul><li>Process state – running, waiting, etc. <code>State</code></li><li>Program counter – location of instruction to next execute <code>PC</code></li><li>CPU registers – contents of all process-centric registers <code>Register</code></li><li>CPU scheduling <strong>information</strong>- priorities, scheduling queue pointers</li><li>Memory-management <strong>information</strong> – memory allocated to the process</li><li>Accounting <strong>information</strong> – CPU used, clock time elapsed since start, time limits</li><li>I/O status <strong>information</strong> – I/O devices allocated to process, list of open files</li></ul></div><blockquote><p>[!abstract]+ A PCB is a kernel data structure</p><ul><li>stored in the memory reserved for the kernel</li><li>invisible to the process itself</li><li>changed only by the kernel.</li></ul></blockquote><blockquote><p>[!abstract]+ Each process has a corresponding unique PCB in the kernel.</p><ul><li>When a new process is created, the kernel creates a new PCB for it.</li><li>When a process dies, the kernel deletes the process’s PCB.</li></ul></blockquote><p>All the PCBs together is how the kernel keeps track of which processes exist in memory, where they are in memory, what they are currently doing (Maybe <code>State</code> ) <img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/OS/StateQueue.png" alt="ReadyQueue"></p><div class="tip custom-block github-alert"><p class="custom-block-title">+ Threads</p><p>If process has a single thread of execution</p><ul><li>One program counter</li></ul><p>If a process has multiple threads of execution</p><ul><li>Kernel will keep the control information for each thread</li><li>Multiple program counters</li></ul></div><h2 id="process-scheduling" tabindex="-1">Process Scheduling <a class="header-anchor" href="#process-scheduling" aria-label="Permalink to &quot;Process Scheduling&quot;">​</a></h2><h3 id="background" tabindex="-1">BackGround <a class="header-anchor" href="#background" aria-label="Permalink to &quot;BackGround&quot;">​</a></h3><ul><li>Several processes want to use one CPU (or CPU core)</li><li>Process scheduler <code>调度</code> (algorithm inside the kernel, software) selects among available processes（i.e. in ready state） for next execution on CPU core <ul><li>Maintains scheduling queues of processes <ul><li>Ready queue – set of all processes residing in main memory, ready and waiting to execute</li></ul></li><li>Wait queues – set of processes waiting for an event (i.e. I/O)</li></ul></li><li>Processes migrate among the various queues</li><li>Scheduling purpose: maximize CPU use, quickly switch processes</li></ul><h3 id="cpu-switch-from-process-to-process" tabindex="-1">CPU Switch From Process to Process <a class="header-anchor" href="#cpu-switch-from-process-to-process" aria-label="Permalink to &quot;CPU Switch From Process to Process&quot;">​</a></h3><p>A context switch occurs when the CPU switches from one process to another. <img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/OS/CPUSwitch.png" alt="CPU Switch From Process to Process"></p><h3 id="context-switch" tabindex="-1">Context Switch <a class="header-anchor" href="#context-switch" aria-label="Permalink to &quot;Context Switch&quot;">​</a></h3><ul><li>When CPU switches to another process, the system must <code>保护现场</code><ul><li>save the state of the old process (the one is running on CPU)</li><li>load the saved state (CPU registers, program counter in PCB) for the new process (the one will run on CPU) via a context switch (i.e., switch PCB)</li></ul></li></ul><div class="note custom-block github-alert"><p class="custom-block-title">+ Context-switch time is</p><p><code>overhead</code></p><ul><li>the system does no useful work while switching</li></ul><p><code>dependent on the complexity of OS</code></p><ul><li>The more complex the OS and the PCB， the longer time the context switch</li></ul><p><code>dependent on hardware support</code></p><ul><li>some hardware provides multiple sets of registers per CPU multiple contexts loaded at once, (no need to switch context when load another process to run)</li></ul></div><h2 id="operations-on-process" tabindex="-1">Operations on Process <a class="header-anchor" href="#operations-on-process" aria-label="Permalink to &quot;Operations on Process&quot;">​</a></h2><div class="note custom-block github-alert"><p class="custom-block-title">+ OS must provide mechanisms for:</p><p>Process Creation Process Termination</p></div><h3 id="process-creation" tabindex="-1">Process Creation <a class="header-anchor" href="#process-creation" aria-label="Permalink to &quot;Process Creation&quot;">​</a></h3><p>Parent process</p><ul><li>Create children processes</li><li>In turn create other processes,</li><li>Finally forming a tree of processes Generally, process is identified and managed via a process identifier (pid)</li></ul><p>Parent and children</p><ul><li><p>Resource sharing options</p><ul><li><ol><li>Parent and children share all resources <code>全共享</code></li></ol></li><li><ol start="2"><li>Children share subset of parent’s resources <code>子进程共享父进程的资源</code></li></ol></li><li><ol start="3"><li>Parent and child share no resources <code>不共享</code></li></ol></li></ul></li><li><p>Execution options</p><ul><li><ol><li>Parent and children execute concurrently \`同时执行</li></ol></li><li><ol start="2"><li>Parent waits until children terminate <code>父进程等待子进程销毁后执行</code></li></ol></li></ul></li></ul><h3 id="process-termination" tabindex="-1">Process Termination <a class="header-anchor" href="#process-termination" aria-label="Permalink to &quot;Process Termination&quot;">​</a></h3><ul><li>Child process asks OS to terminate itself <ul><li>using the exit() system call. <ul><li>Returns status data from child to parent (via wait())</li><li>Process’ resources are deallocated by operating system</li></ul></li></ul></li><li>Parent may terminate the execution of children processes <ul><li>using abort() system call for some reasons: <ol><li>Child has exceeded allocated resources</li><li>Task assigned to child is no longer required</li><li>Parent terminated (some OS do not allow children to be alive)</li></ol></li></ul></li></ul><div class="info custom-block github-alert"><p class="custom-block-title">+ Cascading \`倾泻式的\` termination</p><p></p><ul><li>Some operating systems do not allow child to exist if its parent has terminated.</li><li>When parent is terminated, all children, grandchildren, etc. are terminated.</li><li>The termination is initiated by the operating system.</li></ul></div><p>wait()system call</p><ul><li>The parent process may wait for termination of a child process</li><li>The call returns status information and the pid of the terminated process</li></ul><h3 id="zombie-and-orphan" tabindex="-1">Zombie and Orphan <a class="header-anchor" href="#zombie-and-orphan" aria-label="Permalink to &quot;Zombie and Orphan&quot;">​</a></h3><div class="info custom-block github-alert"><p class="custom-block-title">+ Zombie Process \`僵尸\`</p><p>A <strong>zombie</strong> process is living corpse, <strong>half alive and half dead</strong> terminated, but still consumes system resources</p><ul><li>still has an entry in the process table</li><li>where the entry is still needed to allow the parent process to read its child&#39;s exit status.</li><li>once the exit status is read by parent via the wait system call, the zombie&#39;s entry is removed from the process table (&quot;reaped“).</li></ul></div><blockquote><p>[!example]+ Zombie Program</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdlib.h&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;unistd.h&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;sys/types.h&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	pid_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (pid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* Child */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">		printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Running Child, PID = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getpid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());	</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">		exit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	} 	</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {	</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">		printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Terminating Parent, PID = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getpid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) ;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* Infinite loop */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	} </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></blockquote><p><code>子程序结束却并未通过wait()回收</code></p><blockquote><p>[!abstract]+ Reaping <code>回收</code> Performed by parent on terminated child Parent is given exit status information (by OS) Kernel discards process</p></blockquote><blockquote><p>[!question]+ What if parent doesn’t reap? If any parent terminates without reaping a child, then child will be reaped by init or system process So, only explicitly reaping is needed when parent is a long- running processes. e.g., shells and servers</p></blockquote><div class="info custom-block github-alert"><p class="custom-block-title">+ orphan process \`孤儿\`</p><p>An <strong>orphan</strong> process is child process that is still running but <strong>parent</strong> process has finished or <strong>terminated</strong>.</p></div><blockquote><p>[!example]+ Orphan Program</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdlib.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;unistd.h&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;sys/types.h&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	pid_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (pid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* Child */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">		printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Running Child, PID = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getpid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) ;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* Infinite loop */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {	</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">		printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Terminating Parent, PID = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getpid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">		exit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	} </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>父进程结束了却没有回收子进程</code></p></blockquote><h2 id="inter-process-communication-ipc" tabindex="-1">Inter-process Communication <code>IPC</code> <a class="header-anchor" href="#inter-process-communication-ipc" aria-label="Permalink to &quot;Inter-process Communication \`IPC\`&quot;">​</a></h2><h3 id="background-1" tabindex="-1">BackGround <a class="header-anchor" href="#background-1" aria-label="Permalink to &quot;BackGround&quot;">​</a></h3><div class="info custom-block github-alert"><p class="custom-block-title">+ Processes within a system may be independent or cooperating</p><p></p><ul><li>Independent process cannot affect or be affected by another process</li><li>Cooperating process can affect or be affected by other processes, because they share data</li></ul></div><div class="tip custom-block github-alert"><p class="custom-block-title">+ Advantages/Reasons of process cooperation</p><p></p><ol><li>Information sharing</li><li>Computation speed-up</li><li>Modularity</li><li>Convenience</li></ol></div><div class="tip custom-block github-alert"><p class="custom-block-title">Disadvantages</p><p></p><ol><li>Added complexity</li><li>Deadlocks (死锁) possible</li><li>Starvation (饥饿) possible</li></ol></div><h3 id="communications-models" tabindex="-1">Communications Models <a class="header-anchor" href="#communications-models" aria-label="Permalink to &quot;Communications Models&quot;">​</a></h3><p>Cooperating processes need interprocess communication (IPC)</p><div class="tip custom-block github-alert"><p class="custom-block-title">+ Two models of IPC</p><p></p><ul><li>Shared memory //user processes control</li><li>Message passing //kernel control</li><li>Pipe Communication <img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/OS/CommunicationModel.png" alt="Communication Model"></li></ul></div><h4 id="shared-memory-user-control" tabindex="-1">Shared Memory <code>User Control</code> <a class="header-anchor" href="#shared-memory-user-control" aria-label="Permalink to &quot;Shared Memory \`User Control\`&quot;">​</a></h4><p><strong>Processes communicate through a shared memory</strong></p><h5 id="producer-consumer-problem" tabindex="-1">Producer-Consumer Problem <a class="header-anchor" href="#producer-consumer-problem" aria-label="Permalink to &quot;Producer-Consumer Problem&quot;">​</a></h5><blockquote><p>[!quote]+ Producer process produces information that is consumed by a consumer process</p></blockquote><ul><li><code>Unbounded-buffer</code>: no practical limit on the size of the buffer <ul><li>Producer never has to wait because there is always extra space available for new information;</li><li>Only consumer might have to wait if no information is available to read</li></ul></li><li><code>Bounded-buffer</code>: buffer size is fixed <code>Achieved by 循环队列</code><ul><li>Producer might have to wait if there is no space available to store new information;</li><li>Consumer might have to wait if no information is available to read</li></ul></li></ul><h4 id="message-passing-kernel-control" tabindex="-1">Message Passing <code>Kernel Control</code> <a class="header-anchor" href="#message-passing-kernel-control" aria-label="Permalink to &quot;Message Passing \`Kernel Control\`&quot;">​</a></h4><p>Two operations <code>message size is either fixed or variable</code></p><ul><li>send(message)</li><li>receive(message) A communication link between processes must be created before communication.</li></ul><div class="info custom-block github-alert"><p class="custom-block-title">+ Implementation of communication link</p><p></p><ul><li>Physical level: <ul><li>Shared memory</li><li>Hardware bus</li><li>Network</li></ul></li><li>Logical level: <ul><li>Direct (process to process) or indirect (mail box)</li><li>Synchronous (blocking) or asynchronous (non-blocking)</li><li>Automatic or explicit buffering</li></ul></li></ul></div><h5 id="direct-communication" tabindex="-1">Direct Communication <a class="header-anchor" href="#direct-communication" aria-label="Permalink to &quot;Direct Communication&quot;">​</a></h5><p>In Direct Communication, Processes must name each other explicitly.</p><ul><li>Send() and receive() primitives <code>原语</code> are defined as <ul><li>send (P, message) – send a message to process <code>P</code></li><li>receive(Q, message) – receive a message from process <code>Q</code></li></ul></li></ul><blockquote><p>[!abstract]+ Properties of communication link Links are established automatically A link is associated with exactly one pair of communicating processes Between each pair there exists exactly one link The link may be unidirectional, but is usually bi-directional</p></blockquote><h5 id="indirect-communication" tabindex="-1">Indirect Communication <a class="header-anchor" href="#indirect-communication" aria-label="Permalink to &quot;Indirect Communication&quot;">​</a></h5><div class="tip custom-block github-alert"><p class="custom-block-title">+ MailBox</p><p>Messages are directed and received from <strong>mailboxes</strong> (also referred to as ports <code>端口</code>)</p><ul><li>Each <strong>mailbox</strong> has a unique id <ul><li>Processes can communicate only if they share a mailbox</li><li>Processes can communicate only if they share a mailbox</li></ul></li><li>The send() and receive() primitives are defined as <ul><li>send(A, message) – send a message to mailbox A</li><li>receive(A, message) – receive a message from mailbox A</li></ul></li></ul></div><blockquote><p>[!success]+ MailBox Operations</p><ol><li>Create a new mailbox (port)</li><li>Send and receive messages through mailbox</li><li>Destroy a mailbox</li></ol></blockquote><blockquote><p>[!abstract]+ Properties of communication link</p><ul><li>Link established only if processes share a common mailbox</li><li>A link may be associated with many processes</li><li>Each pair of processes may share several communication links</li><li>Link may be unidirectional or bi-directional</li></ul></blockquote><h5 id="synchronization-同步" tabindex="-1">Synchronization <code>同步</code> <a class="header-anchor" href="#synchronization-同步" aria-label="Permalink to &quot;Synchronization \`同步\`&quot;">​</a></h5><p><strong>Message passing may be either blocking or non-blocking</strong></p><div class="info custom-block github-alert"><p class="custom-block-title">+ Blocking is considered synchronous \`同步\`</p><p></p><ul><li>Blocking send <ul><li>the sender is blocked until the message is received by the receiving process or by the mailbox</li></ul></li><li>Blocking receive <ul><li>the receiver is blocked until a message is available</li></ul></li></ul></div><div class="info custom-block github-alert"><p class="custom-block-title">+ Non-blocking is considered asynchronous \`异步\`</p><p></p><ul><li>Non-blocking send <ul><li>the sender sends the message and continues without waiting for the message to be received</li></ul></li><li>Non-blocking receive <ul><li>the receiver receives: A valid message, or Null message</li></ul></li></ul></div><p>Different combinations possible If both send and receive are blocking, this case is called <strong>rendezvous</strong> <code>会合</code></p><p>Queue of messages attached to the link, in kernel memory Implemented in one of three ways</p><ol><li>Zero capacity – no messages are queued on a link. <ul><li>Sender must wait for receiver (rendezvous)</li></ul></li><li>Bounded capacity – finite length of n messages <ul><li>Sender must wait if link full</li></ul></li><li>Unbounded capacity – infinite length <ul><li>Sender never waits</li></ul></li></ol><h4 id="pipe" tabindex="-1">Pipe <a class="header-anchor" href="#pipe" aria-label="Permalink to &quot;Pipe&quot;">​</a></h4><p>Acts as a conduit <code>管道</code> allowing two processes to communicate on the same computer</p><p>Anonymous <code>Ordinary </code> Pipes</p><ul><li>cannot be accessed from outside the process that created it. <code>匿名进程不能通过外部进程访问</code></li><li>Typically, a parent process creates a pipe and uses it to communicate with a child process that it created.</li></ul><p>Named Pipes</p><ul><li>can be accessed without a parent-child relationship.</li></ul><h5 id="anonymous-ordinary-pipes" tabindex="-1">Anonymous (Ordinary) Pipes <a class="header-anchor" href="#anonymous-ordinary-pipes" aria-label="Permalink to &quot;Anonymous (Ordinary) Pipes&quot;">​</a></h5><ul><li><strong>Ordinary Pipes</strong> allow communication in standard producer-consumer style</li><li>Producer writes to one end (the write-end of the pipe)</li><li>Consumer reads from the other end (the read-end of the pipe)</li><li>Ordinary pipes are therefore unidirectional (单向) <ul><li>create two separate pipes if bidirectional communication is necessary</li></ul></li><li>Require parent-child relationship between communicating processes <img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/OS/Pipe.png" alt="Ordinary  Pipe"></li></ul><h5 id="named-pipes" tabindex="-1">Named Pipes <a class="header-anchor" href="#named-pipes" aria-label="Permalink to &quot;Named Pipes&quot;">​</a></h5><ul><li><strong>Named Pipes</strong> are more powerful than ordinary pipes</li><li>Communication is bidirectional</li><li>No parent-child relationship is necessary between the communicating processes</li><li>Several (&gt;=2) processes can use the named pipe for communication</li><li>Provided on both UNIX and Windows systems</li></ul><h2 id="communication-in-client-server-systems" tabindex="-1">Communication in Client-Server Systems <a class="header-anchor" href="#communication-in-client-server-systems" aria-label="Permalink to &quot;Communication in Client-Server Systems&quot;">​</a></h2><h3 id="sockets" tabindex="-1">Sockets <a class="header-anchor" href="#sockets" aria-label="Permalink to &quot;Sockets&quot;">​</a></h3><div class="info custom-block github-alert"><p class="custom-block-title">+ Socket \`套接字\`</p><p>Endpoint for communication <code>通讯的终结点</code> A number included at start of message packet to differentiate network services on a host</p></div><ul><li>Concatenation of IP address and port <ul><li>E.g., 161.25.19.8:1625</li></ul></li><li>port 1625 on host 161.25.19.8</li><li>All ports below 1024 are well known, used for standard services</li><li>Special IP address 127.0.0.1 (loopback) to refer to system on which process is running Communication happens between a pair of sockets, one on the local host and one on the remote host</li></ul><div class="info custom-block github-alert"><p class="custom-block-title">+ Sock</p><p>A data structure inside the kernel that represents the local end of a network connection IP and Port</p></div><h3 id="remote-procedure-call-rpc" tabindex="-1">Remote Procedure Call <code>RPC</code> <a class="header-anchor" href="#remote-procedure-call-rpc" aria-label="Permalink to &quot;Remote Procedure Call \`RPC\`&quot;">​</a></h3><ul><li>Remote procedure call (RPC) abstracts procedure calls between processes on networked systems <ul><li>Looks like a normal function call but done through the network</li><li>Uses ports for service differentiation</li></ul></li><li>OS typically provides a <strong>matchmaker</strong> service to connect client and server <img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/OS/RPCExecution.png" alt="RPC"></li></ul><blockquote><p>[!abstract]+ RPC Communication Steps</p><ol><li>The client-side stub (server proxy)</li></ol><ul><li>Locates the server</li><li>Marshals the parameters</li><li>Sends parameters to server-side stub in a network message</li></ul><ol start="2"><li>The server-side stub (client proxy)</li></ol><ul><li>Receives this message</li><li>Unpacks the marshaled parameter</li><li>Performs the procedure call on the server, marshals the result of the call</li><li>Sends it back to the client-side stub in another message</li></ul><ol start="3"><li>The client-side stub</li></ol><ul><li>Receives this second message</li><li>Unpacks the marshaled result</li><li>Gives it back to the client that did the RPC</li></ul></blockquote><div class="info custom-block github-alert"><p class="custom-block-title">+ Stubs</p><p></p><ul><li>Manages the network connection between client and server</li><li>Extra code on the client side and server side</li><li>Typically, a separate stub exists for each separate remote procedure</li><li>On Windows, stub code compile from specification written in Microsoft Interface Definition Language (MIDL)</li></ul></div><div class="info custom-block github-alert"><p class="custom-block-title">+ Marshel</p><p>Use External Data Representation (XDR) format to account for different CPU architectures Data Representation can be different in different CPU</p><ul><li><img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/OS/MarshelDataRepresentation.png" alt="DataRepresentation"></li><li>On the client side, parameter marshaling involves converting the machine-dependent data into XDR before they are sent to server.</li><li>On the server side, the XDR data are un-marshaled and converted to the machine-dependent representation for the server.</li></ul></div>`,87))])}const P=n(o,[["render",g]]);export{w as __pageData,P as default};

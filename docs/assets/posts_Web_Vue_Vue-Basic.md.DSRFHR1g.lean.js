import{_ as o,c as p,a5 as a,j as s,t as e,a as l,G as h,B as k,o as r}from"./chunks/framework.CHhwEXkI.js";const V=JSON.parse('{"title":"Vue-Basic","description":"","frontmatter":{"date":"2024-02-07T00:00:00.000Z","title":"Vue-Basic","author":["AllenYGY"],"status":"DONE","tags":["NOTE","Vue","Lec1","WEB"],"created":"2024-03-20T17:14","updated":"2024-05-31T01:27","publish":true},"headers":[],"relativePath":"posts/Web/Vue/Vue-Basic.md","filePath":"posts/Web/Vue/Vue-Basic.md","lastUpdated":null}'),d={name:"posts/Web/Vue/Vue-Basic.md"},u={class:"info custom-block github-alert"},E={class:"info custom-block github-alert"},g={class:"info custom-block github-alert"},c={class:"tip custom-block github-alert"};function b(t,i,y,v,m,q){const n=k("school");return r(),p("div",null,[i[28]||(i[28]=a(`<h1 id="vue-basic" tabindex="-1">Vue-Basic <a class="header-anchor" href="#vue-basic" aria-label="Permalink to &quot;Vue-Basic&quot;">​</a></h1><h2 id="前置" tabindex="-1">前置 <a class="header-anchor" href="#前置" aria-label="Permalink to &quot;前置&quot;">​</a></h2><ul><li>ES6语法规范</li><li>ES6模块化</li><li>包管理器</li><li>原型、原型链</li><li>数组常用方法</li><li><code>axios</code></li><li>promise</li></ul><h2 id="初识vue" tabindex="-1"><strong>初识Vue</strong> <a class="header-anchor" href="#初识vue" aria-label="Permalink to &quot;**初识Vue**&quot;">​</a></h2><ol><li>想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；</li><li>root容器里的代码依然符合html规范，只不过混入了一些特外的Vue语法；</li><li>容器里的代码破称为【Vue模板】;</li><li>容器与实例一一对应；</li><li>真实开发中只有一个Vue实例，并且会配合着组件一起使用；</li><li>｛｛xxx｝｝中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；</li><li>一且data中的数据发生改变，那么模板中用到该数据的地方也会自动更新；</li></ol><h2 id="模版语法" tabindex="-1"><strong>模版语法</strong> <a class="header-anchor" href="#模版语法" aria-label="Permalink to &quot;**模版语法**&quot;">​</a></h2><p>Vue模板语法有2大类：</p><ol><li>插值语法： <ul><li>功能：“用于解析标签体内容。</li><li>写法：｛｛xxx｝｝，xxx是js表达式，且可以直接读取到data中的所有属性。</li></ul></li><li>指令语法： <ul><li>功能：用于解析标签（包括：标签属性、标签体内容、绑定事件..•.）。</li><li>举例：v-bind:href=&quot;xoox&quot;或简写为：href=&quot;xxx&quot;，xoxcx同样要写js表达式，且可以直接读取到data中的所有属性。</li></ul></li></ol><div class="note custom-block github-alert"><p class="custom-block-title">+ #备注</p><p>Vue中有很多的指令，且形式都是：V-2？？？，此处我们只是拿v-bind举个例子。</p></div><h2 id="数据绑定" tabindex="-1"><strong>数据绑定</strong> <a class="header-anchor" href="#数据绑定" aria-label="Permalink to &quot;**数据绑定**&quot;">​</a></h2><p>Vue中有2种数据绑定的方式：</p><ol><li>单向绑定（v-bind）：数据只能从data流向页面。</li><li>双向绑定（Y-model）：数据不仅能从data流向页面，还可以从页面流间data。<div class="note custom-block github-alert"><p class="custom-block-title">+ #备注</p><p></p><ol><li>双向绑定一股都应用在表单类元素上（如：input、select等）</li><li>v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。</li></ol></div></li></ol><h2 id="el与data的两种写法" tabindex="-1"><strong>el与data的两种写法</strong> <a class="header-anchor" href="#el与data的两种写法" aria-label="Permalink to &quot;**el与data的两种写法**&quot;">​</a></h2><ol><li>el有2种写法 <ol><li>new Vue时候h置e1属性。</li><li>先创建Ve刻例，随后再通过vm.$mount(&#39;#root&#39;)指定el的值。</li></ol></li><li>data有2种写法 <ol><li>对象式</li><li>函数式<div class="warning custom-block github-alert"><p class="custom-block-title">+ #备注</p><p>data必须使用函数式，否则会报错。</p></div></li></ol></li><li>一个重要的原则： 由vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。</li></ol><h2 id="mvvm-模型" tabindex="-1"><strong>MVVM 模型</strong> <a class="header-anchor" href="#mvvm-模型" aria-label="Permalink to &quot;**MVVM 模型**&quot;">​</a></h2><ol><li>M: 模型(Model): 对应data中的数据</li><li>V: 视图(View): 模版</li><li>VM: 视图模型(ViewModel): Vue实例对象 <img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/Vue/MVVC.png" alt="MVVC"></li></ol><p>观察发现：</p><ol><li>data中所有的属性，最后都出现在了vm身上。</li><li>vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。</li></ol><h2 id="数据代理" tabindex="-1"><strong>数据代理</strong> <a class="header-anchor" href="#数据代理" aria-label="Permalink to &quot;**数据代理**&quot;">​</a></h2><p>数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）</p><ol><li><div class="note custom-block github-alert"><p class="custom-block-title">+ Vue中的数据代理</p><p>通过vm对象来代理data对象中属性的操作（读/写）</p></div></li><li><div class="note custom-block github-alert"><p class="custom-block-title">+ Vue中数据代理的好处</p><p>更加方便的操作data中的数据</p></div></li><li><div class="note custom-block github-alert"><p class="custom-block-title">+ 基本原理</p><p>通过Object.defineProperty（）把data对象中所有属性添加到vm上。 为每一个添加到vm上的属性，都指定一个getter/setter。 在getter/Fetter内部去採作（读/写）data中对应的属性。</p></div></li></ol><h2 id="事件处理" tabindex="-1"><strong>事件处理</strong> <a class="header-anchor" href="#事件处理" aria-label="Permalink to &quot;**事件处理**&quot;">​</a></h2><h3 id="事件的基本使用" tabindex="-1"><strong>事件的基本使用</strong> <a class="header-anchor" href="#事件的基本使用" aria-label="Permalink to &quot;**事件的基本使用**&quot;">​</a></h3><ol><li>使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；</li><li>事件的回调需要配置在methods对象中，最终会在vm上；</li><li>methods中配置的函数，不要用箭头函数！否则this就不是vm了；</li><li>methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；</li><li>@click=&quot;demo&quot; 和 @click=&quot;demo($event)&quot; 效果一致，但后者可以传参；</li></ol><h3 id="vue中的事件修饰符" tabindex="-1"><strong>Vue中的事件修饰符</strong> <a class="header-anchor" href="#vue中的事件修饰符" aria-label="Permalink to &quot;**Vue中的事件修饰符**&quot;">​</a></h3><ol><li><strong>prevent：阻止默认事件</strong></li><li><strong>stop：阻止事件冒泡</strong></li><li><strong>once：事件只触发一次</strong></li><li>capture：使用事件的捕获模式</li><li>self：只有event.target是当前操作的元素时才触发事件</li><li>passive：事件的默认行为立即执行，无需等待事件回调执行完毕</li></ol><h3 id="键盘事件" tabindex="-1"><strong>键盘事件</strong> <a class="header-anchor" href="#键盘事件" aria-label="Permalink to &quot;**键盘事件**&quot;">​</a></h3><ol><li>Vue中常用的按键别名： <ul><li>回车 =&gt; enter</li><li>删除 =&gt; delete (捕获“删除”和“退格”键)</li><li>退出 =&gt; esc</li><li>空格 =&gt; space</li><li>换行 =&gt; tab (特殊，必须配合keydown去使用)</li><li>上 =&gt; up</li><li>下 =&gt; down</li><li>左 =&gt; left</li><li>右 =&gt; right</li></ul></li><li>Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）</li><li>系统修饰键（用法特殊）：ctrl、alt、shift、meta <ol><li>配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。</li><li>配合keydown使用：正常触发事件。</li></ol></li><li>也可以使用keyCode去指定具体的按键（不推荐）</li><li><code>Vue.config.keyCodes.自定义键名 = 键码</code>，可以去定制按键别名</li></ol><h2 id="计算属性" tabindex="-1"><strong>计算属性</strong> <a class="header-anchor" href="#计算属性" aria-label="Permalink to &quot;**计算属性**&quot;">​</a></h2><ol><li>定义：要用的属性不存在，要通过已有属性计算得来。</li><li>原理：底层借助了Objcet.defineproperty方法提供的getter和setter。</li><li>get函数什么时候执行？</li></ol><blockquote><p>[!question]- Answer</p><ol><li>初次读取时会执行一次。</li><li>当依赖的数据发生改变时会被再次调用。</li></ol></blockquote><ol start="4"><li>优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。</li></ol><div class="note custom-block github-alert"><p class="custom-block-title">-</p><p></p><ol><li>计算属性最终会出现在vm上，直接读取使用即可。</li><li>如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</li></ol></div><h2 id="监视" tabindex="-1"><strong>监视</strong> <a class="header-anchor" href="#监视" aria-label="Permalink to &quot;**监视**&quot;">​</a></h2><h2 id="监视属性-watch" tabindex="-1"><strong>监视属性 watch</strong> <a class="header-anchor" href="#监视属性-watch" aria-label="Permalink to &quot;**监视属性 watch**&quot;">​</a></h2><ol><li>当被监视的属性变化时, 回调函数自动调用, 进行相关操作</li><li>监视的属性必须存在，才能进行监视！！</li><li>监视的两种写法： <ol><li>new Vue时传入watch配置</li><li>通过vm.$watch监视</li></ol></li></ol><h2 id="深度监视" tabindex="-1"><strong>深度监视</strong> <a class="header-anchor" href="#深度监视" aria-label="Permalink to &quot;**深度监视**&quot;">​</a></h2><ol><li>Vue中的watch默认不监测对象内部值的改变（一层）。</li><li>配置deep:true可以监测对象内部值改变（多层）。</li></ol><div class="note custom-block github-alert"><p class="custom-block-title">备注：</p><p></p><ol><li>Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！</li><li>使用watch时根据数据的具体结构，决定是否采用深度监视。</li></ol></div><blockquote><p>[!abstract]+ <strong>Computed Vs Watch</strong> computed和watch之间的区别：</p><ol><li>computed能完成的功能，watch都可以完成。</li><li>watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。</li></ol></blockquote><blockquote><p>[!abstract]+ <strong>两个重要的小原则</strong>：</p><ol><li>所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。</li><li>所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数， 这样this的指向才是vm 或 组件实例对象。</li></ol></blockquote><h2 id="绑定样式" tabindex="-1"><strong>绑定样式</strong> <a class="header-anchor" href="#绑定样式" aria-label="Permalink to &quot;**绑定样式**&quot;">​</a></h2><ol><li>class样式 写法:class=&quot;xxx&quot; xxx可以是字符串、对象、数组。 字符串写法适用于：类名不确定，要动态获取。 对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。 数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</li><li>style样式</li></ol><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:style=&quot;{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fontSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: xxx}&quot;其中xxx是动态值。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:style=&quot;[a,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]&quot;其中a、b是样式对象。</span></span></code></pre></div><h2 id="条件渲染" tabindex="-1"><strong>条件渲染</strong> <a class="header-anchor" href="#条件渲染" aria-label="Permalink to &quot;**条件渲染**&quot;">​</a></h2><h3 id="v-if" tabindex="-1"><strong>v-if</strong> <a class="header-anchor" href="#v-if" aria-label="Permalink to &quot;**v-if**&quot;">​</a></h3><p>写法：</p><ol><li>v-if=&quot;表达式&quot;</li><li>v-else-if=&quot;表达式&quot;</li><li>v-else=&quot;表达式&quot;</li></ol><blockquote><p>[!abstract] Feature 适用于：切换频率较低的场景。 特点：不展示的DOM元素直接被移除。 注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。</p></blockquote><h3 id="v-show" tabindex="-1"><strong>v-show</strong> <a class="header-anchor" href="#v-show" aria-label="Permalink to &quot;**v-show**&quot;">​</a></h3><blockquote><p>[!abstract] Feature 写法：v-show=&quot;表达式&quot; 适用于：切换频率较高的场景。 特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</p></blockquote><div class="note custom-block github-alert"><p class="custom-block-title">+ 备注：</p><p>使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。</p></div><h2 id="列表渲染" tabindex="-1"><strong>列表渲染</strong> <a class="header-anchor" href="#列表渲染" aria-label="Permalink to &quot;**列表渲染**&quot;">​</a></h2><h3 id="基本列表" tabindex="-1"><strong>基本列表</strong> <a class="header-anchor" href="#基本列表" aria-label="Permalink to &quot;**基本列表**&quot;">​</a></h3><blockquote><p>[!abstract] v-for</p><ol><li>用于展示列表数据</li><li>语法：v-for=&quot;(item, index) in xxx&quot; :key=&quot;yyy&quot;</li><li>可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</li></ol></blockquote><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;root&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 遍历数组 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;人员列表（遍历数组）&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;(p,index) of persons&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			{{p.name}}-{{p.age}}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 遍历对象 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;汽车信息（遍历对象）&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    	&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;(value,k) of car&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;k&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    		{{k}}-{{value}}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    	&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 遍历字符串 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;测试遍历字符串（用得少）&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    		&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;(char,index) of str&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    			{{char}}-{{index}}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    		&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    	&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 遍历指定次数 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;测试遍历指定次数（用得少）&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;(number,index) of 5&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">				{{index}}-{{number}}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="key的内部原理" tabindex="-1"><strong>key的内部原理</strong> <a class="header-anchor" href="#key的内部原理" aria-label="Permalink to &quot;**key的内部原理**&quot;">​</a></h3><ol><li>虚拟DOM中key的作用： <ul><li>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】</li><li>随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</li></ul></li><li>对比规则： <ul><li>旧虚拟DOM中找到了与新虚拟DOM相同的key： <ol><li>若虚拟DOM中内容没变, 直接使用之前的真实DOM！</li><li>若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</li></ol></li><li>旧虚拟DOM中未找到与新虚拟DOM相同的key <ul><li>创建新的真实DOM，随后渲染到到页面。</li></ul></li></ul></li><li>用index作为key可能会引发的问题： <ol><li>若对数据进行：逆序添加、逆序删除等破坏顺序操作: 会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</li><li>如果结构中还包含输入类的DOM： 会产生错误DOM更新 ==&gt; 界面有问题。</li></ol></li><li>开发中如何选择key? <ol><li>最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。</li><li>如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</li></ol></li></ol><h3 id="vue监视数据" tabindex="-1"><strong>Vue监视数据</strong> <a class="header-anchor" href="#vue监视数据" aria-label="Permalink to &quot;**Vue监视数据**&quot;">​</a></h3><ol><li><strong>Vue</strong>会监视data中所有层次的数据。</li><li><blockquote><p>[!question]- 如何监测对象中的数据? 通过setter实现监视，且要在new Vue时就传入要监测的数据。</p><ol><li>对象中后追加的属性，Vue默认不做响应式处理</li><li>如需给后添加的属性做响应式，请使用如下API： Vue.set(target，propertyName/index，value) 或 vm.$set(target，propertyName/index，value)</li></ol></blockquote></li><li><blockquote><p>[!question]- 如何监测数组中的数据？ 通过包裹数组更新元素的方法实现，本质就是做了两件事：</p><ol><li>调用原生对应的方法对数组进行更新。</li><li>重新解析模板，进而更新页面。</li></ol></blockquote></li><li><div class="tip custom-block github-alert"><p class="custom-block-title">- 在Vue修改数组中的某个元素一定要用如下方法：</p><p></p><ol><li>使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</li><li>Vue.set() 或 vm.$set()</li></ol></div></li></ol><div class="warning custom-block github-alert"><p class="custom-block-title">- 特别注意</p><p>Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！</p></div><h2 id="收集表单数据" tabindex="-1"><strong>收集表单数据</strong> <a class="header-anchor" href="#收集表单数据" aria-label="Permalink to &quot;**收集表单数据**&quot;">​</a></h2><h3 id="text-input-type" tabindex="-1"><strong>text Input Type</strong> <a class="header-anchor" href="#text-input-type" aria-label="Permalink to &quot;**text Input Type**&quot;">​</a></h3><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;</span></span></code></pre></div><p>则v-model收集的是value值，用户输入的就是value值。</p><h3 id="radio-input-type" tabindex="-1"><strong>radio input type</strong> <a class="header-anchor" href="#radio-input-type" aria-label="Permalink to &quot;**radio input type**&quot;">​</a></h3><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;radio&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;</span></span></code></pre></div><p>则v-model收集的是value值，且要给标签配置value值。</p><h3 id="checkbox-input-type" tabindex="-1"><strong>checkbox input type</strong> <a class="header-anchor" href="#checkbox-input-type" aria-label="Permalink to &quot;**checkbox input type**&quot;">​</a></h3><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;checkbox&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;</span></span></code></pre></div><ol><li>没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）</li><li>配置input的value属性: <ol><li>v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）</li><li>v-model的初始值是数组，那么收集的的就是value组成的数组</li></ol></li></ol><div class="note custom-block github-alert"><p class="custom-block-title">+ v-model的三个修饰符</p><p>lazy：失去焦点再收集数据 number：输入字符串转为有效的数字 trim：输入首尾空格过滤</p></div><h2 id="过滤器" tabindex="-1"><strong>过滤器</strong> <a class="header-anchor" href="#过滤器" aria-label="Permalink to &quot;**过滤器**&quot;">​</a></h2><div class="info custom-block github-alert"><p class="custom-block-title">+ 定义：</p><p>对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。</p></div>`,74)),s("blockquote",null,[i[1]||(i[1]=s("p",null,"[!abstract]+ 语法:",-1)),s("ol",null,[i[0]||(i[0]=s("li",null,"注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:",-1)),s("li",null,"使用过滤器："+e(t.xxx|t.过滤器名)+' 或 v-bind:属性 = "xxx | 过滤器名"',1)])]),i[29]||(i[29]=s("div",{class:"note custom-block github-alert"},[s("p",{class:"custom-block-title"},"+ 备注："),s("p"),s("ol",null,[s("li",null,"过滤器也可以接收额外参数、多个过滤器也可以串联"),s("li",null,"并没有改变原本的数据, 是产生新的对应的数据")])],-1)),i[30]||(i[30]=s("h2",{id:"内置指令",tabindex:"-1"},[s("strong",null,"内置指令"),l(),s("a",{class:"header-anchor",href:"#内置指令","aria-label":'Permalink to "**内置指令**"'},"​")],-1)),i[31]||(i[31]=s("blockquote",null,[s("p",null,"[!abstract]+ Abstract v-bind : 单向绑定解析表达式, 可简写为 :xxx v-model : 双向数据绑定 v-for : 遍历数组/对象/字符串 v-on : 绑定事件监听, 可简写为@ v-if : 条件渲染（动态控制节点是否存存在） v-else : 条件渲染（动态控制节点是否存存在） v-show : 条件渲染 (动态控制节点是否展示)")],-1)),s("div",u,[i[3]||(i[3]=s("p",{class:"custom-block-title"},"+ v-text指令",-1)),i[4]||(i[4]=s("p",null,null,-1)),s("ol",null,[i[2]||(i[2]=s("li",null,"作用：向其所在的节点中渲染文本内容。",-1)),s("li",null,"与插值语法的区别：v-text会替换掉节点中的内容，"+e(t.xx)+"则不会。",1)])]),s("div",E,[i[8]||(i[8]=s("p",{class:"custom-block-title"},"+ v-html指令",-1)),i[9]||(i[9]=s("p",null,null,-1)),s("ol",null,[i[7]||(i[7]=s("li",null,"作用：向指定节点中渲染包含html结构的内容。",-1)),s("li",null,[i[6]||(i[6]=l("与插值语法的区别： ")),s("ol",null,[s("li",null,"v-html会替换掉节点中所有的内容，"+e(t.xx)+"则不会。",1),i[5]||(i[5]=s("li",null,"v-html可以识别html结构。",-1))])])])]),i[32]||(i[32]=s("div",{class:"warning custom-block github-alert"},[s("p",{class:"custom-block-title"},"+ v-html有安全性问题！！！！"),s("p"),s("ol",null,[s("li",null,"在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。"),s("li",null,"一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！")])],-1)),s("div",g,[i[11]||(i[11]=s("p",{class:"custom-block-title"},"+ v-cloak指令（没有值）",-1)),i[12]||(i[12]=s("p",null,null,-1)),s("ol",null,[i[10]||(i[10]=s("li",null,"本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。",-1)),s("li",null,"使用css配合v-cloak可以解决网速慢时页面展示出"+e(t.xxx)+"的问题。",1)])]),i[33]||(i[33]=a(`<blockquote><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">v-cloak</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">none</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;root&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h2</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-cloak</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{name}}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></blockquote><div class="info custom-block github-alert"><p class="custom-block-title">+ v-once指令</p><p></p><ol><li>v-once所在节点在初次动态渲染后，就视为静态内容了。</li><li>以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</li></ol></div><div class="info custom-block github-alert"><p class="custom-block-title">+ v-pre指令：</p><p></p><ol><li>跳过其所在节点的编译过程。</li><li>可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</li></ol></div><h2 id="自定义指令" tabindex="-1"><strong>自定义指令</strong> <a class="header-anchor" href="#自定义指令" aria-label="Permalink to &quot;**自定义指令**&quot;">​</a></h2><h3 id="定义语法" tabindex="-1"><strong>定义语法</strong> <a class="header-anchor" href="#定义语法" aria-label="Permalink to &quot;**定义语法**&quot;">​</a></h3><ol><li>局部指令</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   directives:{指令名：配置对象}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   directives:{指令名：回调函数}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><ol start="2"><li>全局指令</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">directive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(指令名,配置对象) </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">directive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(指令名,回调函数)</span></span></code></pre></div><h3 id="配置对象中常用的3个回调" tabindex="-1"><strong>配置对象中常用的3个回调</strong> <a class="header-anchor" href="#配置对象中常用的3个回调" aria-label="Permalink to &quot;**配置对象中常用的3个回调**&quot;">​</a></h3><ol><li>bind：指令与元素成功绑定时调用。</li><li>inserted：指令所在元素被插入页面时调用。</li><li>update：指令所在模板结构被重新解析时调用。</li></ol><div class="note custom-block github-alert"><p class="custom-block-title">+ 备注</p><p></p><ol><li>指令定义时不加v-，但使用时要加v-；</li><li>指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。</li></ol></div><h2 id="生命周期" tabindex="-1"><strong>生命周期</strong> <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;**生命周期**&quot;">​</a></h2><blockquote><p>[!abstract] 生命周期</p><ol><li>又名：生命周期回调函数、生命周期函数、生命周期钩子。 2.是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。 3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。 4.生命周期函数中的this指向是vm 或 组件实例对象。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/vue/LifeCycle.png" alt="生命周期"></p><div class="info custom-block github-alert"><p class="custom-block-title">+ 常用的生命周期钩子</p><p></p><ol><li>mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等. 【初始化操作】</li><li>beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等. 【收尾工作】</li></ol></div><blockquote><p>[!example]+ 关于销毁<code>Vue</code>实例 1.销毁后借助Vue开发者工具看不到任何信息。 2.销毁后自定义事件会失效，但原生DOM事件依然有效。 3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</p></blockquote><h2 id="组件" tabindex="-1"><strong>组件</strong> <a class="header-anchor" href="#组件" aria-label="Permalink to &quot;**组件**&quot;">​</a></h2><h2 id="vue中使用组件的三大步骤" tabindex="-1"><strong>Vue中使用组件的三大步骤</strong> <a class="header-anchor" href="#vue中使用组件的三大步骤" aria-label="Permalink to &quot;**Vue中使用组件的三大步骤**&quot;">​</a></h2><ol><li>定义组件(创建组件)</li><li>注册组件</li><li>使用组件(写组件标签)</li></ol><blockquote><p>[!question]+ 如何定义一个组件？ 使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；</p></blockquote><p>区别如下：</p><ol><li>el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。</li><li>data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。</li></ol><p>使用template可以配置组件结构。</p><blockquote><p>[!question]+ 如何注册组件？</p><ol><li>局部注册：靠new Vue的时候传入components选项</li><li>全局注册：靠Vue.component(&#39;组件名&#39;,组件)</li></ol></blockquote><blockquote><p>[!question]+ 编写组件标签：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div></blockquote>`,26)),h(n),i[34]||(i[34]=a('<blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span></code></pre></div></blockquote><div class="info custom-block github-alert"><p class="custom-block-title">+ 几个注意点</p><p></p></div><ol><li>关于组件名: <ul><li>一个单词组成： 第一种写法(首字母小写)：school 第二种写法(首字母大写)：School</li><li>多个单词组成： 第一种写法(kebab-case命名)：my-school 第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)</li></ul></li></ol><div class="tip custom-block github-alert"><p class="custom-block-title">+ 注意</p><p></p><ol><li>组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。</li><li>可以使用name配置项指定组件在开发者工具中呈现的名字。</li></ol></div><ol start="2"><li>关于组件标签: <ul><li>第一种写法:<div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">school</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">school</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li><li>第二种写法：<div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">school</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;</span></span></code></pre></div></li></ul></li></ol>',5)),s("div",c,[i[15]||(i[15]=s("p",{class:"custom-block-title"},"+ 注意",-1)),s("p",null,[i[13]||(i[13]=l("不用使用脚手架时，")),h(n),i[14]||(i[14]=l("会导致后续组件不能渲染。"))])]),i[35]||(i[35]=a(`<ol start="3"><li>一个简写方式：</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> school</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">extend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(options) </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//可简写为：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> school</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> options</span></span></code></pre></div><h2 id="vuecomponent" tabindex="-1"><strong>VueComponent</strong> <a class="header-anchor" href="#vuecomponent" aria-label="Permalink to &quot;**VueComponent**&quot;">​</a></h2>`,3)),s("ol",null,[i[24]||(i[24]=s("li",null,"school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。",-1)),s("li",null,[i[16]||(i[16]=l("我们只需要写")),h(n),i[17]||(i[17]=l("或<school></school>，")),i[18]||(i[18]=s("code",null,"Vue",-1)),i[19]||(i[19]=l("解析时会帮我们创建school组件的实例对象， 即")),i[20]||(i[20]=s("code",null,"Vue",-1)),i[21]||(i[21]=l("帮我们执行的：")),i[22]||(i[22]=s("code",null,"new VueComponent(options)",-1)),i[23]||(i[23]=l("。"))]),i[25]||(i[25]=s("li",null,[l("特别注意：每次调用"),s("code",null,"Vue.extend"),l("，返回的都是一个全新的VueComponent！")],-1)),i[26]||(i[26]=s("li",null,[l("关于this指向： "),s("ol",null,[s("li",null,"组件配置中： data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。"),s("li",null,"new Vue(options)配置中： data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。")])],-1)),i[27]||(i[27]=s("li",null,"VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。 Vue的实例对象，以后简称vm。",-1))]),i[36]||(i[36]=s("div",{class:"info custom-block github-alert"},[s("p",{class:"custom-block-title"},"+ 一个重要的内置关系"),s("p",null,[l("VueComponent.prototype."),s("strong",null,"proto"),l(" === Vue.prototype")])],-1)),i[37]||(i[37]=s("blockquote",null,[s("p",null,"[!question]+ 为什么要有这个关系 让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。")],-1))])}const F=o(d,[["render",b]]);export{V as __pageData,F as default};

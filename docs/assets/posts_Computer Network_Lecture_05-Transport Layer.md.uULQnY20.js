import{_ as t,c as a,a5 as o,o as r}from"./chunks/framework.CHhwEXkI.js";const u=JSON.parse('{"title":"05-Transport Layer","description":"","frontmatter":{"date":"2024-05-11T00:00:00.000Z","title":"05-Transport Layer","status":"TOBECONTINUED","author":["AllenYGY"],"tags":["Transport-Layer","NOTE","Network"],"created":"2024-05-11T14:03","updated":"2024-06-11T01:16","publish":true},"headers":[],"relativePath":"posts/Computer Network/Lecture/05-Transport Layer.md","filePath":"posts/Computer Network/Lecture/05-Transport Layer.md","lastUpdated":null}'),i={name:"posts/Computer Network/Lecture/05-Transport Layer.md"};function n(l,e,s,c,p,d){return r(),a("div",null,e[0]||(e[0]=[o('<h1 id="transport-layer" tabindex="-1">Transport Layer <a class="header-anchor" href="#transport-layer" aria-label="Permalink to &quot;Transport Layer&quot;">​</a></h1><h2 id="transport-control-protocol-tcp" tabindex="-1">Transport Control Protocol (TCP) <a class="header-anchor" href="#transport-control-protocol-tcp" aria-label="Permalink to &quot;Transport Control Protocol (TCP)&quot;">​</a></h2><ul><li>Operation of TCP <ul><li>When a sender transmits a segment, it also starts a timer.</li><li>When the segment arrives at the destination, the receiving TCP entity sends back a segment (with data if any) bearing an acknowledgement number equal to the next sequence number it expects to receive.</li><li>If the sender’s timer goes off before the acknowledgement is received, the sender transmits the segment again.</li></ul></li><li>3-way handshaking <ul><li><img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/Network/3way.png" alt="3-way handshaking"></li><li>To release a connection, either party can send a TCP segment with the FIN bit set.</li></ul></li></ul><h2 id="tcp-segments" tabindex="-1">TCP Segments <a class="header-anchor" href="#tcp-segments" aria-label="Permalink to &quot;TCP Segments&quot;">​</a></h2><p><img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/Network/TCP-Segments.png" alt="TCP-Segments"></p><h2 id="data-traffic" tabindex="-1">Data Traffic <a class="header-anchor" href="#data-traffic" aria-label="Permalink to &quot;Data Traffic&quot;">​</a></h2><p>The main focus of congestion control and quality of service is data traffic.</p><ul><li>In congestion control we try to avoid traffic congestion.</li><li>In quality of service, we try to create an appropriate environment for the traffic.</li><li>So, before talking about congestion control and quality of service, we discuss the data traffic itself.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/Network/TrafficProfile.png" alt="Traffic Profile"></p><h3 id="congestion-control" tabindex="-1">Congestion Control <a class="header-anchor" href="#congestion-control" aria-label="Permalink to &quot;Congestion Control&quot;">​</a></h3><p>In general, we can divide congestion control mechanisms into two broad categories: open-loop congestion control (prevention) and closed-loop congestion control (removal).</p><ul><li>Open-loop <ul><li>Retransmission Policy</li><li>Window Policy</li><li>Acknowledgement Policy</li><li>Discard Policy</li><li>Admission Policy</li></ul></li><li>Closed-loop <ul><li>Back Pressure</li><li>Choke Packet</li><li>Implicit signaling</li><li>Explicit signaling</li></ul></li></ul><p>Metrics Used to Monitor a Subnet for Congestion</p><ul><li>Percentage of all packets discarded for lack of buffer space;</li><li>Average of queue lengths;</li><li>Number of packets that time out and are retransmitted;</li><li>Average packet delay;</li><li>Standard deviation of packet delay, etc.</li></ul>',14)]))}const f=t(i,[["render",n]]);export{u as __pageData,f as default};

import{_ as e,c as a,a5 as i,o as r}from"./chunks/framework.CHhwEXkI.js";const m=JSON.parse('{"title":"04-Network Layer","description":"","frontmatter":{"date":"2024-04-24T00:00:00.000Z","title":"04-Network Layer","status":"TOBECONTINUED","author":["AllenYGY"],"tags":["Network-Layer","NOTE","Network"],"created":"2024-04-24T20:24","updated":"2024-05-29T12:22","publish":true},"headers":[],"relativePath":"posts/Computer Network/Lecture/04-Network Layer.md","filePath":"posts/Computer Network/Lecture/04-Network Layer.md","lastUpdated":null}'),o={name:"posts/Computer Network/Lecture/04-Network Layer.md"};function n(d,t,l,s,h,c){return r(),a("div",null,t[0]||(t[0]=[i(`<h1 id="network-layer" tabindex="-1">Network Layer <a class="header-anchor" href="#network-layer" aria-label="Permalink to &quot;Network Layer&quot;">​</a></h1><h2 id="internet-protocol" tabindex="-1">Internet Protocol <a class="header-anchor" href="#internet-protocol" aria-label="Permalink to &quot;Internet Protocol&quot;">​</a></h2><pre><code> An IP datagram consists of a header part and a text part. 
</code></pre><h3 id="ipv4" tabindex="-1">IPv4 <a class="header-anchor" href="#ipv4" aria-label="Permalink to &quot;IPv4&quot;">​</a></h3><p><img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/Network/IPv4.png" alt="Ipv4"></p><ul><li>IPv4 Header <ul><li>The header has a 20-byte fixed part and a variable length optional part. <ul><li>Fixed Part include: <ul><li>Version</li><li>IHL</li><li>TOS</li><li>Total Length</li><li>Identification</li><li>DF and MF</li><li>Fragment offset</li><li>TTL</li><li>Protocol</li><li>Header checksum</li><li>Source address and destination address</li></ul></li></ul></li></ul></li></ul><h4 id="ipv4-header-part" tabindex="-1">IPv4 Header Part <a class="header-anchor" href="#ipv4-header-part" aria-label="Permalink to &quot;IPv4 Header Part&quot;">​</a></h4><h4 id="version" tabindex="-1">Version <a class="header-anchor" href="#version" aria-label="Permalink to &quot;Version&quot;">​</a></h4><p>Version: to keep track of which version of the protocol the datagram belongs to. <code>4 bit</code></p><h4 id="ihl" tabindex="-1">IHL <a class="header-anchor" href="#ihl" aria-label="Permalink to &quot;IHL&quot;">​</a></h4><p>IHL: to provide the length of the header, in 32-bit words. <code>4 bit</code> - When the value is 5, which applies no options are present.</p><h4 id="tos" tabindex="-1">TOS <a class="header-anchor" href="#tos" aria-label="Permalink to &quot;TOS&quot;">​</a></h4><p>TOS: (Type of service) to distinguish between different classes of services. <code>8 bit</code> - Three-bit precedence field and three flags, D, T, and R {Delay, Throughput and Reliability}. <code>3 bit</code> - 三位优先字段（precedence field）和三标志位（D、T、R）用于指示数据报的服务质量需求和优先级。这些字段通常位于IPv4首部的服务类型（Type of Service, TOS）字段中。</p><table tabindex="0"><thead><tr><th>TOS Bits</th><th>Description</th></tr></thead><tbody><tr><td>0000</td><td>Normal (default)</td></tr><tr><td>0001</td><td>Minimize cost</td></tr><tr><td>0010</td><td>Maximize reliability</td></tr><tr><td>0100</td><td>Maximize throughput</td></tr><tr><td>1000</td><td>Minimize delay</td></tr></tbody></table><p>这个表格展示了服务类型字段的不同比特组合及其对应的描述。每种组合表示数据报在传输过程中不同的服务质量要求，例如默认服务、最小化成本、最大化可靠性、最大化吞吐量和最小化延迟。</p><h4 id="total-length" tabindex="-1">Total Length <a class="header-anchor" href="#total-length" aria-label="Permalink to &quot;Total Length&quot;">​</a></h4><p>Total Length: to provide the length of the datagram (including header and data). <code>16 bit</code></p><h4 id="identification" tabindex="-1">Identification <a class="header-anchor" href="#identification" aria-label="Permalink to &quot;Identification&quot;">​</a></h4><ul><li>Identification: to identify each datagram. <code>16 bit</code></li></ul><h4 id="fragment-and-fragment-offset" tabindex="-1">Fragment and Fragment offset <a class="header-anchor" href="#fragment-and-fragment-offset" aria-label="Permalink to &quot;Fragment and Fragment offset&quot;">​</a></h4><ul><li>DF and MF: don’t fragment, and more fragments. <code>3 bit</code></li><li>Fragment offset: To tell where in the current datagram this fragment belongs. <code>13 bit</code></li></ul><h4 id="ttl" tabindex="-1">TTL <a class="header-anchor" href="#ttl" aria-label="Permalink to &quot;TTL&quot;">​</a></h4><ul><li>Time to live: a counter used to limit packet lifetimes. <code>8 bit</code></li></ul><h4 id="protocol-and-header-checksum" tabindex="-1">Protocol and Header Checksum <a class="header-anchor" href="#protocol-and-header-checksum" aria-label="Permalink to &quot;Protocol and Header Checksum&quot;">​</a></h4><ul><li>Protocol: to tell which protocol process to give it to (e.g., TCP or UDP). <code>8 bit</code></li><li>Header checksum: to detect errors in the datagram. <code>16 bit</code></li></ul><h4 id="source-address-and-destination-address" tabindex="-1">Source address and Destination address <a class="header-anchor" href="#source-address-and-destination-address" aria-label="Permalink to &quot;Source address and Destination address&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/Network/Addressclassification.png" alt="Address Classification"></p><ul><li><p>Source address and destination address <code>32 bit</code></p></li><li><p>Unique: no two machines on the Internet have the same IP address.</p></li></ul><p>32-bit long.</p><h4 id="ipv4-summary" tabindex="-1">IPV4 Summary <a class="header-anchor" href="#ipv4-summary" aria-label="Permalink to &quot;IPV4 Summary&quot;">​</a></h4><table tabindex="0"><thead><tr><th>字段</th><th>比特数</th><th>功能描述</th></tr></thead><tbody><tr><td>版本 (Version)</td><td>4</td><td>标识IP协议的版本，IPv4的版本字段值为4</td></tr><tr><td>首部长度 (IHL)</td><td>4</td><td>指示IP数据报首部的长度，以32位（4字节）为单位</td></tr><tr><td>服务类型 (TOS)</td><td>8</td><td>指定数据报的优先级和服务质量</td></tr><tr><td>总长度</td><td>16</td><td>指示整个IP数据报的总长度，包括首部和数据部分，以字节为单位</td></tr><tr><td>标识 (Identification)</td><td>16</td><td>唯一标识数据报，以便在需要时进行分片和重组</td></tr><tr><td>标志 (Flags)</td><td>3</td><td>控制和识别数据报的分片，包括不分片位（DF）和更多分片位（MF）</td></tr><tr><td>片偏移 (Fragment Offset)</td><td>13</td><td>指示数据报片在原始数据报中的相对位置，以8字节为单位</td></tr><tr><td>生存时间 (TTL)</td><td>8</td><td>限制数据报在网络中的生存时间，防止无限循环</td></tr><tr><td>协议 (Protocol)</td><td>8</td><td>指示数据报携带的数据所使用的协议，如TCP、UDP等</td></tr><tr><td>首部校验和 (Header Checksum)</td><td>16</td><td>验证IP首部的完整性</td></tr><tr><td>源地址 (Source Address)</td><td>32</td><td>表示数据报发送方的IP地址</td></tr><tr><td>目的地址 (Destination Address)</td><td>32</td><td>表示数据报接收方的IP地址</td></tr><tr><td>选项 (Options)</td><td>可变</td><td>支持其他的控制功能和服务，长度可变，最多可达40字节</td></tr></tbody></table><p>总结：IPv4首部的基本部分是20字节（160位），但如果包含选项字段，长度可能会超过20字节。选项字段的长度是可变的，最大可达40字节，因此整个IPv4首部的最大长度是60字节。</p><h3 id="ipv6" tabindex="-1">IPv6 <a class="header-anchor" href="#ipv6" aria-label="Permalink to &quot;IPv6&quot;">​</a></h3><p><img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/Network/IPv6.png" alt="IPv6"></p><h3 id="transition-from-ipv4-to-ipv6" tabindex="-1">Transition from IPv4 to IPv6 <a class="header-anchor" href="#transition-from-ipv4-to-ipv6" aria-label="Permalink to &quot;Transition from IPv4 to IPv6&quot;">​</a></h3><ul><li>Three transition strategies <ul><li><code>Dual stack</code></li><li><code>Tunneling</code></li><li><code>Header translation</code></li></ul></li></ul><h4 id="dual-stack" tabindex="-1">Dual Stack <a class="header-anchor" href="#dual-stack" aria-label="Permalink to &quot;Dual Stack&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/Network/Transition-DualStack.png" alt="Dual Stack"></p><h4 id="tunneling" tabindex="-1">Tunneling <a class="header-anchor" href="#tunneling" aria-label="Permalink to &quot;Tunneling&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/Network/Transition-Tunneling.png" alt="Tunneling "></p><h4 id="header-translation" tabindex="-1">Header Translation <a class="header-anchor" href="#header-translation" aria-label="Permalink to &quot;Header Translation&quot;">​</a></h4><p><img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/Network/Translation-Header.png" alt="Header Translation"></p><h2 id="network-routing" tabindex="-1">Network Routing <a class="header-anchor" href="#network-routing" aria-label="Permalink to &quot;Network Routing&quot;">​</a></h2><h3 id="delivery" tabindex="-1">Delivery <a class="header-anchor" href="#delivery" aria-label="Permalink to &quot;Delivery&quot;">​</a></h3><ul><li>The network layer supervises the handling of the packets by the underlying physical networks.</li><li>We define this handling as the delivery of a packet.</li><li>Direct and indirect delivery</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ALLENYGY/ImageSpace@master/IMAGE/Network/Delivery.png" alt="Delivery"></p><h3 id="forwarding" tabindex="-1">Forwarding <a class="header-anchor" href="#forwarding" aria-label="Permalink to &quot;Forwarding&quot;">​</a></h3><ul><li>Forwarding means to place the packet in its route to its destination. <code>转发</code></li><li>Forwarding requires a host or a router to have a routing table.</li><li>When a host has a packet to send or when a router has received a packet to be forwarded, it looks at this table to find the route to the final destination.</li></ul><h3 id="routing-algorithms" tabindex="-1">Routing Algorithms <a class="header-anchor" href="#routing-algorithms" aria-label="Permalink to &quot;Routing Algorithms&quot;">​</a></h3><p>Shortest Path Routing</p><ul><li>To study the routing algorithms, a <em><strong>graph</strong></em> is commonly used to represent a subnet.</li><li>Each node of the graph represents a router and each arc of the graph represents a communication line.</li><li>The path length can be measured in terms of <em>the number of hops</em>, <em>the geographic distance</em>, etc.</li></ul><h4 id="dijkstra-algorithm" tabindex="-1">Dijkstra Algorithm <a class="header-anchor" href="#dijkstra-algorithm" aria-label="Permalink to &quot;Dijkstra Algorithm&quot;">​</a></h4><blockquote><p>[!abstract]+ Dijkstra Algorithm</p><ol><li>Set the value of the initial node to zero and set all other nodes to infinity.</li><li>Mark all nodes unvisited. Set the initial node as starting point.</li><li>For the current node, consider all of its unvisited neighbors and calculate their tentative distances.</li><li>Mark the current node as visited and remove it from the unvisited set. A visited node will never be checked again.</li><li>If the destination node has been marked visited or if the smallest tentative distance among the nodes in the unvisited set is infinity, then stop. The algorithm has finished.</li><li>Set the unvisited node marked with the smallest tentative distance as the next current node and go back to step 3.</li></ol></blockquote><h4 id="flooding-algorithm" tabindex="-1">Flooding Algorithm <a class="header-anchor" href="#flooding-algorithm" aria-label="Permalink to &quot;Flooding Algorithm&quot;">​</a></h4><ol><li>Every incoming packet is sent out on every outgoing line except the one it arrived on.</li><li>To solve the vast numbers of duplicate packets, a hop counter is introduced.</li><li>The hop counter is contained in the header of each packet.</li><li>It decremented at each hop. The packet will be discarded when the counter reached zero.</li></ol><h4 id="distance-vector-routing" tabindex="-1">Distance Vector Routing <a class="header-anchor" href="#distance-vector-routing" aria-label="Permalink to &quot;Distance Vector Routing&quot;">​</a></h4><ol><li>It is a dynamic routing algorithm.</li><li>Each router maintains a table giving the best known distance to each destination and which line to use to get there.</li><li>These tables are updated by exchanging information with their neighbors.</li><li>An entry of routing tables contains two parts: the preferred outgoing line to be used for the destination, and an estimate of the distance to that destination.</li></ol><h4 id="link-state-routing" tabindex="-1">Link State Routing <a class="header-anchor" href="#link-state-routing" aria-label="Permalink to &quot;Link State Routing&quot;">​</a></h4>`,58)]))}const p=e(o,[["render",n]]);export{m as __pageData,p as default};
